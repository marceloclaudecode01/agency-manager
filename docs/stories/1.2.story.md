# Story 1.2 — Implementar refresh token

**Status:** Ready
**Epic:** Epic 1 — Correção Crítica de Autenticação
**Priority:** P0

## Descrição
Como usuário da plataforma, quero que minha sessão seja renovada automaticamente após expirar para que eu não seja deslogado inesperadamente durante o trabalho.

## Contexto Técnico

### Problema atual
**`backend/src/modules/auth/auth.service.ts` (linha 39–43):** O token JWT gerado no login tem validade fixa de 7 dias sem mecanismo de renovação:
```typescript
const token = jwt.sign(
  { id: user.id, email: user.email, role: user.role },
  JWT_SECRET,
  { expiresIn: '7d' }
);
```

Após 7 dias o usuário recebe 401 em todas as requisições e é deslogado abruptamente, sem aviso ou tentativa de renovação.

**`frontend/src/lib/api.ts` (linhas 16–27):** O interceptor de resposta atual ao receber 401 apenas limpa o `localStorage` e força redirect para login — não há tentativa de refresh:
```typescript
if (error.response?.status === 401 && typeof window !== 'undefined' && !isAuthRoute) {
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  window.location.href = '/login';
}
```

### Solução
Implementar dois tokens distintos:
- **Access token:** curta duração (15 minutos), enviado como cookie httpOnly `access_token`
- **Refresh token:** longa duração (30 dias), enviado como cookie httpOnly `refresh_token`

O frontend intercepta respostas 401 e tenta `POST /api/auth/refresh` automaticamente antes de redirecionar ao login. O refresh token é invalidado no logout.

A revogação de refresh tokens usará blacklist em memória (Map no processo Node.js) — não requer alteração no banco nesta story.

### Dependência de Story 1.1
Esta story pressupõe que o mecanismo de cookie httpOnly já está funcionando (Story 1.1 concluída). O `auth.service.ts` deve ter o método `generateToken()` disponível (criado na Story 1.1).

## Escopo

### IN (o que fazer)
- [ ] **Backend — `auth.service.ts`:** Criar método `generateAccessToken(user)` que assina JWT com `expiresIn: '15m'`
- [ ] **Backend — `auth.service.ts`:** Criar método `generateRefreshToken(user)` que assina JWT com secret separado `REFRESH_TOKEN_SECRET` e `expiresIn: '30d'`
- [ ] **Backend — `auth.service.ts`:** Criar blacklist em memória: `const refreshTokenBlacklist = new Set<string>()` — com métodos `addToBlacklist(token: string)` e `isBlacklisted(token: string): boolean`
- [ ] **Backend — `auth.service.ts`:** Criar método `refreshAccessToken(refreshToken: string)` que: (1) verifica se está na blacklist, (2) valida assinatura com `REFRESH_TOKEN_SECRET`, (3) retorna novo access token
- [ ] **Backend — `auth.service.ts`:** Atualizar método `login()` para retornar `{ user, accessToken, refreshToken }` em vez de `{ user, token }`
- [ ] **Backend — `auth.controller.ts`:** Atualizar método `login()` para setar dois cookies: `access_token` (maxAge: 15 min) e `refresh_token` (maxAge: 30 dias), ambos com `httpOnly: true, secure: NODE_ENV === 'production', sameSite: 'strict'`
- [ ] **Backend — `auth.controller.ts`:** Atualizar método `register()` para setar os mesmos dois cookies
- [ ] **Backend — `auth.controller.ts`:** Criar método `refresh(req, res)` que lê `req.cookies.refresh_token`, chama `authService.refreshAccessToken()`, e seta novo cookie `access_token`
- [ ] **Backend — `auth.controller.ts`:** Atualizar método `logout()` para: adicionar `refresh_token` do cookie à blacklist, expirar ambos os cookies (`access_token` e `refresh_token`)
- [ ] **Backend — `auth.routes.ts`:** Adicionar rota `POST /refresh` sem `authMiddleware` (o refresh token é a própria credencial): `router.post('/refresh', (req, res) => controller.refresh(req, res))`
- [ ] **Backend — `auth.schema.ts`:** Não requer schema Zod para o endpoint de refresh (token vem do cookie, não do body)
- [ ] **Backend — `src/middlewares/auth.ts`:** Atualizar `authMiddleware` para ler o access token do cookie `access_token` além do header `Authorization: Bearer` — ordem de prioridade: (1) cookie `access_token`, (2) header Bearer
- [ ] **Backend — `.env`:** Adicionar variável `REFRESH_TOKEN_SECRET` — documentar no `tech-stack.md` e no `CLAUDE.md`
- [ ] **Frontend — `api.ts`:** Reescrever o interceptor de response para 401: antes de redirecionar ao login, tentar `POST /api/auth/refresh` (sem body, pois o refresh token vai no cookie). Se refresh bem-sucedido, retentar a requisição original. Se refresh falhar (401 ou 403), aí sim redirecionar para `/login`
- [ ] **Frontend — `api.ts`:** Usar flag `_retry` na config da requisição para evitar loop infinito de retentativas em caso de falha no próprio endpoint `/auth/refresh`

### OUT (o que NÃO fazer nesta story)
- Persistir refresh tokens no banco PostgreSQL (blacklist em memória é suficiente por ora)
- Implementar rotação de refresh tokens (emitir novo refresh token a cada uso)
- UI de aviso ao usuário sobre expiração iminente
- Alterar lógica do `middleware.ts` do Next.js (escopo da Story 1.3)
- Implementar revogação em múltiplos servidores/instâncias (não se aplica ao deploy atual)

## Critérios de Aceitação
- [ ] **AC1:** Dado que o usuário faz login, quando a resposta chega, então o browser tem dois cookies httpOnly: `access_token` (expira em 15 min) e `refresh_token` (expira em 30 dias)
- [ ] **AC2:** Dado que o `access_token` expirou (15 min após login), quando o frontend faz qualquer requisição à API e recebe 401, então o interceptor automaticamente chama `POST /api/auth/refresh`, recebe novo `access_token` no cookie, e retenta a requisição original sem que o usuário perceba interrupção
- [ ] **AC3:** Dado que tanto o `access_token` quanto o `refresh_token` expiraram (ou o `refresh_token` foi invalidado via logout), quando o frontend tenta fazer refresh e recebe 401, então o usuário é redirecionado para `/login`
- [ ] **AC4:** Dado que o usuário clica em logout, quando `POST /api/auth/logout` é chamado, então o `refresh_token` é adicionado à blacklist e ambos os cookies são expirados — uma tentativa posterior de usar o mesmo `refresh_token` retorna 401
- [ ] **AC5:** Dado que `REFRESH_TOKEN_SECRET` não está definido no `.env`, quando o servidor inicia, então deve lançar erro explícito (não silenciar `undefined`)

## Dependências
**Story 1.1 deve estar concluída** — esta story pressupõe:
- Cookie httpOnly funcionando no login/register/logout
- `withCredentials: true` configurado no Axios do frontend
- `cookie-parser` instalado no backend

## Arquivos Afetados
```
backend/src/modules/auth/auth.service.ts      — generateAccessToken, generateRefreshToken, refreshAccessToken, blacklist
backend/src/modules/auth/auth.controller.ts   — atualizar login/register; criar refresh(); atualizar logout()
backend/src/modules/auth/auth.routes.ts       — adicionar POST /refresh
backend/src/middlewares/auth.ts               — ler access_token do cookie além do header Bearer
backend/.env                                  — adicionar REFRESH_TOKEN_SECRET
frontend/src/lib/api.ts                       — reescrever interceptor 401 com lógica de retry após refresh
```

## Estimativa
G (Grande)

## Change Log
- 2026-02-27: Story criada por @sm
- 2026-02-27: Validação PO concluída por @po — Score 10/10, veredicto GO, status alterado para Ready
