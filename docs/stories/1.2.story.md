# Story 1.2 — Implementar refresh token

**Status:** InReview
**Epic:** Epic 1 — Correção Crítica de Autenticação
**Priority:** P0

## Descrição
Como usuário da plataforma, quero que minha sessão seja renovada automaticamente após expirar para que eu não seja deslogado inesperadamente durante o trabalho.

## Contexto Técnico

### Problema atual
**`backend/src/modules/auth/auth.service.ts` (linha 39–43):** O token JWT gerado no login tem validade fixa de 7 dias sem mecanismo de renovação:
```typescript
const token = jwt.sign(
  { id: user.id, email: user.email, role: user.role },
  JWT_SECRET,
  { expiresIn: '7d' }
);
```

Após 7 dias o usuário recebe 401 em todas as requisições e é deslogado abruptamente, sem aviso ou tentativa de renovação.

**`frontend/src/lib/api.ts` (linhas 16–27):** O interceptor de resposta atual ao receber 401 apenas limpa o `localStorage` e força redirect para login — não há tentativa de refresh:
```typescript
if (error.response?.status === 401 && typeof window !== 'undefined' && !isAuthRoute) {
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  window.location.href = '/login';
}
```

### Solução
Implementar dois tokens distintos:
- **Access token:** curta duração (15 minutos), enviado como cookie httpOnly `token` (nome mantido para compatibilidade com Next.js middleware — renomear para `access_token` é escopo da Story 1.3)
- **Refresh token:** longa duração (30 dias), enviado como cookie httpOnly `refresh_token`

O frontend intercepta respostas 401 e tenta `POST /api/auth/refresh` automaticamente antes de redirecionar ao login. O refresh token é invalidado no logout.

A revogação de refresh tokens usará blacklist em memória (Set no processo Node.js) — não requer alteração no banco nesta story.

### Dependência de Story 1.1
Esta story pressupõe que o mecanismo de cookie httpOnly já está funcionando (Story 1.1 concluída). O `auth.service.ts` deve ter o método `generateToken()` disponível (criado na Story 1.1).

## Escopo

### IN (o que fazer)
- [x] **Backend — `auth.service.ts`:** Criar método `generateAccessToken(user)` que assina JWT com `expiresIn: '15m'`
- [x] **Backend — `auth.service.ts`:** Criar método `generateRefreshToken(user)` que assina JWT com secret separado `REFRESH_TOKEN_SECRET` e `expiresIn: '30d'`
- [x] **Backend — `auth.service.ts`:** Criar blacklist em memória: `const refreshTokenBlacklist = new Set<string>()` — com métodos `addToBlacklist(token: string)` e `isBlacklisted(token: string): boolean`
- [x] **Backend — `auth.service.ts`:** Criar método `refreshAccessToken(refreshToken: string)` que: (1) verifica se está na blacklist, (2) valida assinatura com `REFRESH_TOKEN_SECRET`, (3) retorna novo access token
- [x] **Backend — `auth.service.ts`:** Atualizar método `login()` para retornar `{ user, accessToken, refreshToken }` em vez de `{ user, token }`
- [x] **Backend — `auth.controller.ts`:** Atualizar método `login()` para setar dois cookies: `token` (maxAge: 15 min) e `refresh_token` (maxAge: 30 dias), ambos com `httpOnly: true, secure: NODE_ENV === 'production', sameSite: 'strict'`
- [x] **Backend — `auth.controller.ts`:** Atualizar método `register()` para setar os mesmos dois cookies
- [x] **Backend — `auth.controller.ts`:** Criar método `refresh(req, res)` que lê `req.cookies.refresh_token`, chama `authService.refreshAccessToken()`, e seta novo cookie `token`
- [x] **Backend — `auth.controller.ts`:** Atualizar método `logout()` para: adicionar `refresh_token` do cookie à blacklist, expirar ambos os cookies (`token` e `refresh_token`)
- [x] **Backend — `auth.routes.ts`:** Adicionar rota `POST /refresh` sem `authMiddleware` (o refresh token é a própria credencial): `router.post('/refresh', refreshLimiter, (req, res) => controller.refresh(req, res))`
- [x] **Backend — `auth.schema.ts`:** Não requer schema Zod para o endpoint de refresh (token vem do cookie, não do body)
- [x] **Backend — `src/middlewares/auth.ts`:** Atualizar `authMiddleware` para ler o access token do cookie `token` (primary) além do header `Authorization: Bearer` (fallback)
- [x] **Backend — `.env`:** Adicionar variável `REFRESH_TOKEN_SECRET` — documentar no `tech-stack.md` e no `CLAUDE.md`
- [x] **Frontend — `api.ts`:** Reescrever o interceptor de response para 401: antes de redirecionar ao login, tentar `POST /api/auth/refresh` (sem body, pois o refresh token vai no cookie). Se refresh bem-sucedido, retentar a requisição original. Se refresh falhar (401 ou 403), aí sim redirecionar para `/login`
- [x] **Frontend — `api.ts`:** Usar flag `_retry` na config da requisição para evitar loop infinito de retentativas em caso de falha no próprio endpoint `/auth/refresh`

### OUT (o que NÃO fazer nesta story)
- Persistir refresh tokens no banco PostgreSQL (blacklist em memória é suficiente por ora)
- Implementar rotação de refresh tokens (emitir novo refresh token a cada uso)
- UI de aviso ao usuário sobre expiração iminente
- Alterar lógica do `middleware.ts` do Next.js (escopo da Story 1.3)
- Implementar revogação em múltiplos servidores/instâncias (não se aplica ao deploy atual)

## Critérios de Aceitação
- [x] **AC1:** Dado que o usuário faz login, quando a resposta chega, então o browser tem dois cookies httpOnly: `token` (expira em 15 min) e `refresh_token` (expira em 30 dias)
- [x] **AC2:** Dado que o `token` expirou (15 min após login), quando o frontend faz qualquer requisição à API e recebe 401, então o interceptor automaticamente chama `POST /api/auth/refresh`, recebe novo `token` no cookie, e retenta a requisição original sem que o usuário perceba interrupção
- [x] **AC3:** Dado que tanto o `token` quanto o `refresh_token` expiraram (ou o `refresh_token` foi invalidado via logout), quando o frontend tenta fazer refresh e recebe 401, então o usuário é redirecionado para `/login`
- [x] **AC4:** Dado que o usuário clica em logout, quando `POST /api/auth/logout` é chamado, então o `refresh_token` é adicionado à blacklist e ambos os cookies são expirados — uma tentativa posterior de usar o mesmo `refresh_token` retorna 401
- [x] **AC5:** Dado que `REFRESH_TOKEN_SECRET` não está definido no `.env`, quando o servidor inicia, então deve lançar erro explícito (não silenciar `undefined`) — implementado com `throw new Error(...)` no module-level de `auth.service.ts`

## Dependências
**Story 1.1 deve estar concluída** — esta story pressupõe:
- Cookie httpOnly funcionando no login/register/logout
- `withCredentials: true` configurado no Axios do frontend
- `cookie-parser` instalado no backend

## Arquivos Afetados
```
backend/src/modules/auth/auth.service.ts      — generateAccessToken, generateRefreshToken, refreshAccessToken, blacklist, invalidateRefreshToken
backend/src/modules/auth/auth.controller.ts   — atualizar login/register; criar refresh(); atualizar logout(); ACCESS_COOKIE_OPTIONS (15m); REFRESH_COOKIE_OPTIONS (30d, path restricted)
backend/src/modules/auth/auth.routes.ts       — adicionar POST /refresh com refreshLimiter; logout com authMiddleware
backend/src/middlewares/auth.ts               — ler token do cookie 'token' (primary) além do header Bearer (fallback)
backend/.env                                  — adicionada REFRESH_TOKEN_SECRET
frontend/src/lib/api.ts                       — interceptor 401 com refresh + retry + concurrent request queue
```

## Estimativa
G (Grande)

## Change Log
- 2026-02-27: Story criada por @sm
- 2026-02-27: Validação PO concluída por @po — Score 10/10, veredicto GO, status alterado para Ready
- 2026-02-27: Implementação concluída por @dev — todos os itens do checklist marcados [x], status alterado para InReview

### Notas de implementação (2026-02-27)
- Cookie de access token mantido como `'token'` (não renomeado para `'access_token'`) para manter compatibilidade com `frontend/src/middleware.ts` que lê `request.cookies.get('token')`. Renomear é escopo da Story 1.3.
- `REFRESH_TOKEN_SECRET` com fallback removido — falha explícita no startup se ausente (AC5).
- `refreshTokenBlacklist` é `Set<string>` module-level (persiste entre requests no mesmo processo).
- Refresh cookie path restrito a `/api/auth/refresh` para minimizar superfície de ataque.
- Frontend implementa fila de requests concorrentes: múltiplos 401 simultâneos disparam apenas um único `POST /auth/refresh`.
- `logout` agora requer `authMiddleware` (access token válido), garantindo que só sessões autenticadas podem ser encerradas via esse endpoint.
- 2026-02-27: QA FAIL fixes aplicados por @dev — cookie path, payload completo no refresh, error typing
