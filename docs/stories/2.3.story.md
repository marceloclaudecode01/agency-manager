# Story 2.3 — Atualização Otimista + Rollback em Erro de API

**Status:** Done
**Epic:** Kanban Drag-and-Drop
**Priority:** P1

## Descrição
Como usuário da agência, quero que o card se mova imediatamente ao soltar no Kanban para que a interface seja fluida, e que ele retorne à posição original se a API falhar, para que eu tenha feedback honesto sobre o resultado da operação.

## Contexto Técnico
Atualmente (após Story 2.2), o card só muda de coluna visualmente após a resposta da API — o que cria um delay perceptível e flickering. A solução é atualização otimista: mover o card no estado local imediatamente ao `onDragEnd`, guardar o estado anterior como snapshot, e reverter se a API retornar erro.

Estado local relevante: `tasks` (array de `Task[]`) em `tasks/page.tsx`. O estado do board é derivado filtrando esse array por `task.status`.

Não há biblioteca de estado global (Redux, Zustand) no projeto — o estado vive em `useState` no `page.tsx`. A invalidação pós-sucesso deve chamar `loadData()` existente para resync com o servidor.

## Escopo

### IN
- [x] No `onDragEnd`, antes de chamar a API, salvar snapshot do array `tasks` atual em variável local (`previousTasks`)
- [x] Atualizar `setTasks` imediatamente com o novo status do card (otimismo)
- [x] Adicionar estado `pendingTaskId: string | null` para rastrear o card com chamada em andamento
- [x] Enquanto `pendingTaskId` está definido para um card, renderizar overlay sutil no `TaskCard` (spinner ou opacidade + `cursor-wait`) e bloquear novo drag desse card
- [x] Se a API retornar erro: chamar `setTasks(previousTasks)` (rollback) + exibir toast de erro com mensagem descritiva
- [x] Se a API retornar sucesso: limpar `pendingTaskId` + chamar `loadData()` para resync silencioso
- [x] Garantir que múltiplos drags concorrentes em cards diferentes não causem race condition (cada drag gerencia seu próprio snapshot via closure)

### OUT
- Reordenação dentro da mesma coluna
- Fila de operações offline / retry automático
- Sincronização em tempo real via WebSocket (já existe socket.io no projeto, mas fora do escopo desta story)

## Critérios de Aceitação
- [x] AC1: Dado que o usuário solta um card em nova coluna, então o card aparece imediatamente na nova coluna sem aguardar a resposta da API (sem delay visual)
- [x] AC2: Dado que a API retorna erro após o drop, então o card retorna à coluna original e um toast de erro é exibido em até 100ms após a resposta
- [x] AC3: Dado que um card está aguardando resposta da API, então esse card exibe overlay de loading e não pode ser arrastado novamente até a operação finalizar
- [x] AC4: Dado que dois cards diferentes são arrastados em sequência rápida, então cada um tem seu próprio snapshot e o rollback de um não afeta o outro
- [x] AC5: Dado que a API retorna sucesso, então `loadData()` é chamado e o estado local fica em sync com o banco de dados
- [x] AC6: A transição de ida e de rollback são visualmente fluidas — sem flickering brusco

## Dependências
Story 2.2 — Drag entre colunas com update de status via API (handler `onDragEnd` e chamada `api.patch` já implementados).

## Arquivos Afetados
- `C:\Users\MARCELO SANTOS\Desktop\test\frontend\src\app\(dashboard)\tasks\page.tsx` — lógica otimista no onDragEnd, estado pendingTaskId
- `C:\Users\MARCELO SANTOS\Desktop\test\frontend\src\components\tasks\TaskCard.tsx` — overlay de loading quando isPending

## Estimativa
P

## Change Log
- 2026-02-27: Story criada por @sm
- 2026-02-27: Validado por @po — GO 9/10. Status: Ready.
- 2026-02-27: Implementado por @dev — otimistic update + rollback em `tasks/page.tsx`; `isPending` overlay em `TaskCard.tsx`. Status: InReview.
