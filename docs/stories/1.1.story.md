# Story 1.1 — Padronizar token storage (cookie httpOnly)

**Status:** InReview
**Epic:** Epic 1 — Correção Crítica de Autenticação
**Priority:** P0

## Descrição
Como usuário da plataforma, quero que meu token de autenticação seja armazenado em cookie httpOnly para que o sistema funcione de forma consistente em produção sem loops de redirect.

## Contexto Técnico

### Problema atual
Existe uma dessincronia crítica entre dois mecanismos de leitura do token:

**`frontend/src/lib/api.ts` (linhas 6–14):** O token é lido do `localStorage`:
```typescript
const token = localStorage.getItem('token');
if (token) {
  config.headers.Authorization = `Bearer ${token}`;
}
```

**`frontend/src/middleware.ts` (linha 7):** O middleware do Next.js lê do cookie:
```typescript
const token = request.cookies.get('token')?.value;
```

**`frontend/src/app/(dashboard)/layout.tsx` (linha 15):** O layout também lê do `localStorage`:
```typescript
const token = localStorage.getItem('token');
```

**Resultado:** Após login, o token vai para o `localStorage` (via `api.ts`), mas o `middleware.ts` procura em cookie. Como o cookie nunca é setado, o middleware sempre considera o usuário não autenticado e redireciona para `/login`, causando o loop em produção.

**`backend/src/modules/auth/auth.controller.ts` (linha 23–24):** O controller retorna o token no body JSON, não seta `Set-Cookie`:
```typescript
const result = await authService.login(email, password);
return ApiResponse.success(res, result, 'Login successful');
```

**`backend/src/middlewares/auth.ts` (linhas 7–13):** O middleware de auth do backend lê apenas do header `Authorization: Bearer`, não de cookie — este comportamento deve ser mantido para chamadas de API, mas o backend precisa passar a setar o cookie no login/register/logout.

### Solução
O backend deve setar `Set-Cookie` com `httpOnly`, `secure`, `sameSite=strict` nas respostas de login e register. O frontend deve parar de usar `localStorage` para o token e configurar `withCredentials: true` no Axios para que os cookies sejam enviados automaticamente nas requisições à API.

## Escopo

### IN (o que fazer)
- [x] **Backend — `auth.controller.ts`:** No método `login`, após autenticação bem-sucedida, setar cookie via `res.cookie('token', token, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', maxAge: 7 * 24 * 60 * 60 * 1000 })` — manter o token no body da resposta por compatibilidade temporária
- [x] **Backend — `auth.controller.ts`:** No método `register`, após criação do usuário, gerar token JWT (mover geração do token para `auth.service.ts` se ainda não estiver lá) e setar o mesmo cookie
- [x] **Backend — `auth.routes.ts`:** Adicionar rota `POST /logout` que seta `Set-Cookie: token=; expires=Thu, 01 Jan 1970 00:00:00 GMT; httpOnly; path=/` para limpar o cookie
- [x] **Backend — `auth.service.ts`:** Extrair geração do token JWT para método público `generateToken(user)` — atualmente o token é gerado apenas no `login`, mas o `register` também precisará gerar
- [x] **Backend — `server.ts`:** Garantir que `cors` está configurado com `credentials: true` e que `cookie-parser` está instalado e usado como middleware
- [x] **Frontend — `api.ts`:** Adicionar `withCredentials: true` na instância do axios: `const api = axios.create({ baseURL: ..., withCredentials: true })`
- [x] **Frontend — `api.ts`:** Remover o interceptor de request que lê `localStorage.getItem('token')` e injeta `Authorization: Bearer` — o cookie será enviado automaticamente pelo browser
- [x] **Frontend — `api.ts`:** No interceptor de response (erro 401), remover `localStorage.removeItem('token')` e `localStorage.removeItem('user')` — chamar o endpoint `POST /auth/logout` ou apenas redirecionar para `/login`
- [x] **Frontend — `(dashboard)/layout.tsx`:** Remover a verificação `localStorage.getItem('token')` das linhas 14–22 — a proteção de rota passa a ser responsabilidade exclusiva do `middleware.ts` (Story 1.3). O layout não deve mais fazer redirect manual
- [x] **Frontend — contexto de auth (se existir `AuthContext`):** Remover toda leitura/escrita de token no `localStorage`. O estado de autenticação deve ser obtido via `GET /api/auth/me` — aplicado em `hooks/useAuth.ts`
- [x] **Verificar:** `cookie-parser` deve estar listado em `backend/package.json` como dependência; instalar se ausente (`npm install cookie-parser @types/cookie-parser`)

### OUT (o que NÃO fazer nesta story)
- Implementar refresh token (escopo da Story 1.2)
- Reescrever ou alterar a lógica de redirect do `middleware.ts` (escopo da Story 1.3)
- Alterar o schema do Prisma ou criar tabelas no banco
- Alterar a lógica de `authMiddleware` no backend para ler cookies em vez de `Authorization` header — manter leitura via header para compatibilidade com chamadas de API futuras

## Critérios de Aceitação
- [ ] **AC1:** Dado que o usuário faz login com credenciais válidas, quando a resposta é recebida, então o browser deve ter um cookie `token` com flags `httpOnly` e `secure` (em produção) visível na aba Application > Cookies do DevTools — e o `localStorage` NÃO deve conter chave `token`
- [ ] **AC2:** Dado que o usuário está autenticado (cookie presente), quando o frontend faz qualquer chamada à API (ex: `GET /api/clients`), então o cookie é enviado automaticamente e o backend responde com 200 (sem necessitar do header `Authorization` manual)
- [ ] **AC3:** Dado que o usuário clica em logout, quando o endpoint `POST /api/auth/logout` é chamado, então o cookie `token` é expirado/removido e o usuário é redirecionado para `/login`
- [ ] **AC4:** Dado que o usuário está em `/login` com um cookie `token` válido, quando acessa a URL diretamente, então é redirecionado para `/dashboard` (comportamento existente no middleware, mas agora com a fonte correta)
- [ ] **AC5:** Dado que o sistema está em produção (Railway + Vercel), quando o usuário faz login, então não ocorre loop de redirect entre `/login` e `/dashboard`

## Dependências
Nenhuma — esta é a story base do Epic 1. Stories 1.2 e 1.3 dependem desta.

## Arquivos Afetados
```
backend/src/modules/auth/auth.controller.ts   — Set-Cookie no login/register; método logout adicionado
backend/src/modules/auth/auth.service.ts      — generateToken() extraído como método público; register agora retorna {user, token}
backend/src/modules/auth/auth.routes.ts       — rota POST /logout adicionada
backend/src/server.ts                         — cookie-parser importado e aplicado como middleware
frontend/src/lib/api.ts                       — withCredentials:true; removido interceptor de request com localStorage; removidos localStorage.removeItem no 401
frontend/src/app/(dashboard)/layout.tsx       — removida verificação localStorage, removido redirect manual, removido estado isAuth/loading de auth
frontend/src/hooks/useAuth.ts                 — removido localStorage token/user; login/register confiam no cookie httpOnly; logout chama POST /api/auth/logout; useEffect carrega user via GET /auth/me
```

## Estimativa
M (Médio)

## Change Log
- 2026-02-27: Story criada por @sm
- 2026-02-27: Validação PO concluída por @po — Score 10/10, veredicto GO, status alterado para Ready
- 2026-02-27: Implementação concluída por @dev — status alterado para InReview
  - Instalado cookie-parser e @types/cookie-parser no backend
  - auth.service.ts: extraído generateToken() público; register agora gera e retorna token
  - auth.controller.ts: login e register setam cookie httpOnly; logout adicionado (expira cookie)
  - auth.routes.ts: rota POST /logout adicionada
  - server.ts: cookieParser() registrado como middleware (antes do express.json)
  - frontend/src/lib/api.ts: withCredentials:true; removido request interceptor de localStorage; removidos localStorage.removeItem no handler 401
  - frontend/src/app/(dashboard)/layout.tsx: removida lógica de auth/redirect via localStorage; layout agora renderiza diretamente
  - frontend/src/hooks/useAuth.ts: removida toda leitura/escrita de localStorage para token; user carregado via GET /auth/me; logout chama POST /auth/logout
- 2026-02-27: QA fixes aplicados por @dev (LOW issues: @types em devDeps, cookie options consistentes)
